---
layout:     post
title:      java面试基础
subtitle:   
date:       2018-12-12
author:     Don
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Java
    - Android
    - Interview
---

#### 1. 面向对象和面向过程的区别

- 面向过程

优点：性能比面向对象高，因为面向对象中类的调用时需要实例化，开销比较大，比较消耗资源；比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。

缺点：不如面向对象易维护、易复用、易扩展

- 面向对象

优点：易维护、易复用、易扩展；由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、更易维护

缺点： 性能不如面向过程高

- 什么是面向对象    
笔者曾专门介绍过面向对象思想，有兴趣的可以<a href="http://rjgc.cn/2018/12/12/Java%E5%AD%A6%E4%B9%A0%E4%BA%86%E9%82%A3%E4%B9%88%E5%A4%9A%E5%B9%B4%E8%BF%98%E4%B8%8D%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%90%97/" target="_blank">点此</a>查看

#### 2.Java语言有哪些特点

1. 简单易学  
2. 面向对象(封装、继承、多态)  
3. 平台无关性(Java虚拟机实现平台无关性)  
4. 可靠性  
5. 安全性  
6. 支持多线程(C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而java语言却提供了多线程支持)    
7. 支持网络编程而且很方便(Java语言的诞生本身就是为了简化网络编程设计的)  
8. 编译与解释并存

#### 3.JVM、JDK和JRE

- JVM

Java虚拟机(JVM)是运行Java字节码的虚拟机。JVM针对不同的系统有特定的实现(Windows，Linux，macOS),目的是使用相同的字节码他们都会给出相同的结果，也就是所谓的平台无关性

- JDK和JRE

JDK是Java development kit ,它是功能齐全的Java SDK. 它拥有JRE所拥有的一切，还有编译器(javac)和工具(如javadoc和jdb)，它能够穿件和编译程序

JRE是Java运行时环境。它是运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机(JVM)，Java类库，Java命令和其他的一些基础构件，但是它不能穿件新程序

#### 4.字符型常量和字符串常量的区别

1. 形式上： 字符常量使用单引号引起的单个字符，而字符串常量是用双引号引起的若干个字符

2. 含以上： 字符常量相当于一个整形值(ASCII值)，可以参加表达式运算，字符串常量代表一个地址值(该字符串在内存中存放位置)

3. 占内存大小： 字符常量只占2个字节，字符串常量占若干个字节(PS: char在Java中占2个字节)

#### 4.Java面向对象编程的三大特性：封装、继承、多态
笔者曾专门介绍过面向对象思想，有兴趣的可以<a href="http://rjgc.cn/2018/12/12/Java%E5%AD%A6%E4%B9%A0%E4%BA%86%E9%82%A3%E4%B9%88%E5%A4%9A%E5%B9%B4%E8%BF%98%E4%B8%8D%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%90%97/" target="_blank">点此</a>查看

#### 5.String、StringBuffer和StringBuilder的区别

- 可变性   
String内部使用final关键字保存字符串，所以String对象是不可变的；
StringBuffer和StringBuilder都没有使用关键字final,所以这2中对象是可变的

- 线程安全   
String中的对象是不可变的，也就可以理解为常亮，线程安全  

StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以也是线程安全的

StringBuilder没有对方法加同步锁，所以是非线程安全的

- 性能  
每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。  

StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%-15%左右的性能提升，当时却要冒多线程不安全的风险

对于三者使用的总结：   
1. 操作少量的数据用String  
2. 单线程操作字符串缓冲区下操作大量数据用StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据用StringBuffer

#### 6.自动装箱与拆箱
装箱： 将基本类型用他们对应的引用类型包装起来  

拆箱： 将包装类型转换为基本数据类型

#### 7.在一个静态方法内调用一个非静态成员为什么是非法的

因为静态方法可以不通过对象进行调用，因此在静态方法中不能调用其他非静态变量，也不可以方位非静态变量成员

#### 8.在Java中定义一个不做事且没有参数的构造方法的作用

Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中有没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。

#### 9.接口和抽象类的区别

1. 接口的方法默认是public，所有方法在接口中不能有实现(Java8开始接口方法可以有默认实现)，抽象类中可以有非抽象的方法    
2. 接口中的实例变量默认是final类型的，而抽象类中则不一定    
3. 一个类中可以实现多个接口，但最多只能实现一个抽象类   
4. 实现接口时要实现所有的方法，而抽象类不一定    
5. 接口不能用new实例化，但是可以声明，但是必须引用你一个实现该接口的对象，从设计层面来说，抽象是对类的抽象，是一种设计模式，接口是行为的抽象，是一种行为的规范

#### 10.静态方法和实例方法有何不同

1. 在外部调用静态方法时，可以使用“类名。方法名”的方式，也可以使用“对象名。方法名”的方式，但是实例方法只有后面这种方式。

2. 静态方法访问本类的成员时只允许访问静态成员(静态方法和静态变量)，而不允许访问实例成员变量和实例方法